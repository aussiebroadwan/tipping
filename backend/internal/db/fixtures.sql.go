// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: fixtures.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFixture = `-- name: CreateFixture :one
INSERT INTO fixtures (competition_id, roundTitle, matchState, venue, venueCity, matchCentreUrl, kickOffTime) 
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, competition_id, roundtitle, matchstate, venue, venuecity, matchcentreurl, kickofftime
`

type CreateFixtureParams struct {
	CompetitionID  int32
	Roundtitle     *string
	Matchstate     *string
	Venue          *string
	Venuecity      *string
	Matchcentreurl *string
	Kickofftime    pgtype.Timestamp
}

func (q *Queries) CreateFixture(ctx context.Context, arg CreateFixtureParams) (*Fixture, error) {
	row := q.db.QueryRow(ctx, createFixture,
		arg.CompetitionID,
		arg.Roundtitle,
		arg.Matchstate,
		arg.Venue,
		arg.Venuecity,
		arg.Matchcentreurl,
		arg.Kickofftime,
	)
	var i Fixture
	err := row.Scan(
		&i.ID,
		&i.CompetitionID,
		&i.Roundtitle,
		&i.Matchstate,
		&i.Venue,
		&i.Venuecity,
		&i.Matchcentreurl,
		&i.Kickofftime,
	)
	return &i, err
}

const deleteFixture = `-- name: DeleteFixture :exec
DELETE FROM fixtures WHERE id = $1
`

func (q *Queries) DeleteFixture(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteFixture, id)
	return err
}

const getFixtureByID = `-- name: GetFixtureByID :one
SELECT id, competition_id, roundtitle, matchstate, venue, venuecity, matchcentreurl, kickofftime FROM fixtures WHERE id = $1
`

func (q *Queries) GetFixtureByID(ctx context.Context, id int32) (*Fixture, error) {
	row := q.db.QueryRow(ctx, getFixtureByID, id)
	var i Fixture
	err := row.Scan(
		&i.ID,
		&i.CompetitionID,
		&i.Roundtitle,
		&i.Matchstate,
		&i.Venue,
		&i.Venuecity,
		&i.Matchcentreurl,
		&i.Kickofftime,
	)
	return &i, err
}

const getFixturesByCompetitionID = `-- name: GetFixturesByCompetitionID :many
SELECT id, competition_id, roundtitle, matchstate, venue, venuecity, matchcentreurl, kickofftime FROM fixtures 
WHERE competition_id = $1
ORDER BY kickOffTime
`

func (q *Queries) GetFixturesByCompetitionID(ctx context.Context, competitionID int32) ([]*Fixture, error) {
	rows, err := q.db.Query(ctx, getFixturesByCompetitionID, competitionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Fixture
	for rows.Next() {
		var i Fixture
		if err := rows.Scan(
			&i.ID,
			&i.CompetitionID,
			&i.Roundtitle,
			&i.Matchstate,
			&i.Venue,
			&i.Venuecity,
			&i.Matchcentreurl,
			&i.Kickofftime,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFixtures = `-- name: ListFixtures :many
SELECT id, competition_id, roundtitle, matchstate, venue, venuecity, matchcentreurl, kickofftime FROM fixtures
`

func (q *Queries) ListFixtures(ctx context.Context) ([]*Fixture, error) {
	rows, err := q.db.Query(ctx, listFixtures)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Fixture
	for rows.Next() {
		var i Fixture
		if err := rows.Scan(
			&i.ID,
			&i.CompetitionID,
			&i.Roundtitle,
			&i.Matchstate,
			&i.Venue,
			&i.Venuecity,
			&i.Matchcentreurl,
			&i.Kickofftime,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFixture = `-- name: UpdateFixture :one
UPDATE fixtures 
SET 
    competition_id = COALESCE($2, competition_id), 
    roundTitle = COALESCE($3, roundTitle), 
    matchState = COALESCE($4, matchState), 
    venue = COALESCE($5, venue), 
    venueCity = COALESCE($6, venueCity), 
    matchCentreUrl = COALESCE($7, matchCentreUrl), 
    kickOffTime = COALESCE($8, kickOffTime)
WHERE id = $1
RETURNING id, competition_id, roundtitle, matchstate, venue, venuecity, matchcentreurl, kickofftime
`

type UpdateFixtureParams struct {
	ID             int32
	CompetitionID  int32
	Roundtitle     *string
	Matchstate     *string
	Venue          *string
	Venuecity      *string
	Matchcentreurl *string
	Kickofftime    pgtype.Timestamp
}

// Conditionally update fixture details based on provided arguments.
func (q *Queries) UpdateFixture(ctx context.Context, arg UpdateFixtureParams) (*Fixture, error) {
	row := q.db.QueryRow(ctx, updateFixture,
		arg.ID,
		arg.CompetitionID,
		arg.Roundtitle,
		arg.Matchstate,
		arg.Venue,
		arg.Venuecity,
		arg.Matchcentreurl,
		arg.Kickofftime,
	)
	var i Fixture
	err := row.Scan(
		&i.ID,
		&i.CompetitionID,
		&i.Roundtitle,
		&i.Matchstate,
		&i.Venue,
		&i.Venuecity,
		&i.Matchcentreurl,
		&i.Kickofftime,
	)
	return &i, err
}
