// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: fixtures.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createFixture = `-- name: CreateFixture :one
INSERT INTO fixtures (
  competition_id, roundTitle, matchState, venue, venueCity, matchCentreUrl, kickOffTime
) VALUES (
  $1, $2, $3, $4, $5, $6, $7
)
RETURNING id, competition_id, roundtitle, matchstate, venue, venuecity, matchcentreurl, kickofftime
`

type CreateFixtureParams struct {
	CompetitionID  int32
	Roundtitle     *string
	Matchstate     *string
	Venue          *string
	Venuecity      *string
	Matchcentreurl *string
	Kickofftime    pgtype.Timestamp
}

// Insert a new fixture into the fixtures table.
// This query adds a new fixture record with the specified details, such as
// competition ID, round title, match state, venue, venue city, match center URL,
// and kickoff time.
func (q *Queries) CreateFixture(ctx context.Context, arg CreateFixtureParams) (*Fixture, error) {
	row := q.db.QueryRow(ctx, createFixture,
		arg.CompetitionID,
		arg.Roundtitle,
		arg.Matchstate,
		arg.Venue,
		arg.Venuecity,
		arg.Matchcentreurl,
		arg.Kickofftime,
	)
	var i Fixture
	err := row.Scan(
		&i.ID,
		&i.CompetitionID,
		&i.Roundtitle,
		&i.Matchstate,
		&i.Venue,
		&i.Venuecity,
		&i.Matchcentreurl,
		&i.Kickofftime,
	)
	return &i, err
}

const getFixtureByID = `-- name: GetFixtureByID :one
SELECT id, competition_id, roundtitle, matchstate, venue, venuecity, matchcentreurl, kickofftime FROM fixtures WHERE id = $1
`

// Retrieve a specific fixture by its unique identifier.
// Useful for fetching details about a single fixture based on its ID.
func (q *Queries) GetFixtureByID(ctx context.Context, id int32) (*Fixture, error) {
	row := q.db.QueryRow(ctx, getFixtureByID, id)
	var i Fixture
	err := row.Scan(
		&i.ID,
		&i.CompetitionID,
		&i.Roundtitle,
		&i.Matchstate,
		&i.Venue,
		&i.Venuecity,
		&i.Matchcentreurl,
		&i.Kickofftime,
	)
	return &i, err
}

const getFixturesByCompetitionID = `-- name: GetFixturesByCompetitionID :many
SELECT id, competition_id, roundtitle, matchstate, venue, venuecity, matchcentreurl, kickofftime FROM fixtures 
WHERE competition_id = $1
ORDER BY kickOffTime
`

// Retrieve fixtures for a specific competition, ordered by kickoff time.
// This query fetches all fixtures for a given competition ID, ordered by their
// kickoff time to display them in chronological order.
func (q *Queries) GetFixturesByCompetitionID(ctx context.Context, competitionID int32) ([]*Fixture, error) {
	rows, err := q.db.Query(ctx, getFixturesByCompetitionID, competitionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Fixture
	for rows.Next() {
		var i Fixture
		if err := rows.Scan(
			&i.ID,
			&i.CompetitionID,
			&i.Roundtitle,
			&i.Matchstate,
			&i.Venue,
			&i.Venuecity,
			&i.Matchcentreurl,
			&i.Kickofftime,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFixtures = `-- name: ListFixtures :many
SELECT id, competition_id, roundtitle, matchstate, venue, venuecity, matchcentreurl, kickofftime FROM fixtures
`

// Retrieve all fixtures available in the system.
// This query is used to list all fixtures without filtering by any criteria.
func (q *Queries) ListFixtures(ctx context.Context) ([]*Fixture, error) {
	rows, err := q.db.Query(ctx, listFixtures)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Fixture
	for rows.Next() {
		var i Fixture
		if err := rows.Scan(
			&i.ID,
			&i.CompetitionID,
			&i.Roundtitle,
			&i.Matchstate,
			&i.Venue,
			&i.Venuecity,
			&i.Matchcentreurl,
			&i.Kickofftime,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFixture = `-- name: UpdateFixture :one
UPDATE fixtures 
SET 
    competition_id = COALESCE($2, competition_id),
    roundTitle = COALESCE($3, roundTitle),
    matchState = COALESCE($4, matchState),
    venue = COALESCE($5, venue),
    venueCity = COALESCE($6, venueCity),
    matchCentreUrl = COALESCE($7, matchCentreUrl),
    kickOffTime = COALESCE($8, kickOffTime)
WHERE id = $1
RETURNING id, competition_id, roundtitle, matchstate, venue, venuecity, matchcentreurl, kickofftime
`

type UpdateFixtureParams struct {
	ID             int32
	CompetitionID  int32
	Roundtitle     *string
	Matchstate     *string
	Venue          *string
	Venuecity      *string
	Matchcentreurl *string
	Kickofftime    pgtype.Timestamp
}

// Conditionally update fixture details based on provided arguments.
// This query updates the fields of a fixture record where the provided arguments
// are not NULL. It uses the COALESCE function to retain the existing value if
// the argument is NULL.
func (q *Queries) UpdateFixture(ctx context.Context, arg UpdateFixtureParams) (*Fixture, error) {
	row := q.db.QueryRow(ctx, updateFixture,
		arg.ID,
		arg.CompetitionID,
		arg.Roundtitle,
		arg.Matchstate,
		arg.Venue,
		arg.Venuecity,
		arg.Matchcentreurl,
		arg.Kickofftime,
	)
	var i Fixture
	err := row.Scan(
		&i.ID,
		&i.CompetitionID,
		&i.Roundtitle,
		&i.Matchstate,
		&i.Venue,
		&i.Venuecity,
		&i.Matchcentreurl,
		&i.Kickofftime,
	)
	return &i, err
}
