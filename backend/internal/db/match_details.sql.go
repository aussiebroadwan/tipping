// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: match_details.sql

package db

import (
	"context"
)

const createMatchDetail = `-- name: CreateMatchDetail :one
INSERT INTO match_details (
  fixture_id, homeTeam_id, awayTeam_id, homeTeam_odds, awayTeam_odds, 
  homeTeam_score, awayTeam_score, homeTeam_form, awayTeam_form, winner_teamId
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
ON CONFLICT DO NOTHING
RETURNING fixture_id, hometeam_id, awayteam_id, hometeam_odds, awayteam_odds, hometeam_score, awayteam_score, hometeam_form, awayteam_form, winner_teamid
`

type CreateMatchDetailParams struct {
	FixtureID     int64
	HometeamID    int64
	AwayteamID    int64
	HometeamOdds  *float64
	AwayteamOdds  *float64
	HometeamScore *int32
	AwayteamScore *int32
	HometeamForm  string
	AwayteamForm  string
	WinnerTeamid  *int64
}

// Insert a new match detail record into the match_details table.
// If a match detail with the same fixture_id already exists, do nothing.
func (q *Queries) CreateMatchDetail(ctx context.Context, arg CreateMatchDetailParams) (*MatchDetail, error) {
	row := q.db.QueryRow(ctx, createMatchDetail,
		arg.FixtureID,
		arg.HometeamID,
		arg.AwayteamID,
		arg.HometeamOdds,
		arg.AwayteamOdds,
		arg.HometeamScore,
		arg.AwayteamScore,
		arg.HometeamForm,
		arg.AwayteamForm,
		arg.WinnerTeamid,
	)
	var i MatchDetail
	err := row.Scan(
		&i.FixtureID,
		&i.HometeamID,
		&i.AwayteamID,
		&i.HometeamOdds,
		&i.AwayteamOdds,
		&i.HometeamScore,
		&i.AwayteamScore,
		&i.HometeamForm,
		&i.AwayteamForm,
		&i.WinnerTeamid,
	)
	return &i, err
}

const getMatchDetailsByFixtureID = `-- name: GetMatchDetailsByFixtureID :one
SELECT md.fixture_id, md.hometeam_id, md.awayteam_id, md.hometeam_odds, md.awayteam_odds, md.hometeam_score, md.awayteam_score, md.hometeam_form, md.awayteam_form, md.winner_teamid, f.id, f.competition_id, f.roundtitle, f.matchstate, f.venue, f.venuecity, f.matchcentreurl, f.kickofftime, home_team.team_id, home_team.nickname, home_team.competition_id, away_team.team_id, away_team.nickname, away_team.competition_id
FROM match_details md
JOIN fixtures f ON md.fixture_id = f.id
JOIN teams home_team ON md.homeTeam_id = home_team.id
JOIN teams away_team ON md.awayTeam_id = away_team.id
WHERE md.fixture_id = $1
ORDER BY f.kickOffTime
`

type GetMatchDetailsByFixtureIDRow struct {
	MatchDetail MatchDetail
	Fixture     Fixture
	Team        Team
	Team_2      Team
}

// Retrieve match details for a specific fixture by its unique fixture ID.
func (q *Queries) GetMatchDetailsByFixtureID(ctx context.Context, fixtureID int64) (*GetMatchDetailsByFixtureIDRow, error) {
	row := q.db.QueryRow(ctx, getMatchDetailsByFixtureID, fixtureID)
	var i GetMatchDetailsByFixtureIDRow
	err := row.Scan(
		&i.MatchDetail.FixtureID,
		&i.MatchDetail.HometeamID,
		&i.MatchDetail.AwayteamID,
		&i.MatchDetail.HometeamOdds,
		&i.MatchDetail.AwayteamOdds,
		&i.MatchDetail.HometeamScore,
		&i.MatchDetail.AwayteamScore,
		&i.MatchDetail.HometeamForm,
		&i.MatchDetail.AwayteamForm,
		&i.MatchDetail.WinnerTeamid,
		&i.Fixture.ID,
		&i.Fixture.CompetitionID,
		&i.Fixture.Roundtitle,
		&i.Fixture.Matchstate,
		&i.Fixture.Venue,
		&i.Fixture.Venuecity,
		&i.Fixture.Matchcentreurl,
		&i.Fixture.Kickofftime,
		&i.Team.TeamID,
		&i.Team.Nickname,
		&i.Team.CompetitionID,
		&i.Team_2.TeamID,
		&i.Team_2.Nickname,
		&i.Team_2.CompetitionID,
	)
	return &i, err
}

const listMatchDetails = `-- name: ListMatchDetails :many
SELECT md.fixture_id, md.hometeam_id, md.awayteam_id, md.hometeam_odds, md.awayteam_odds, md.hometeam_score, md.awayteam_score, md.hometeam_form, md.awayteam_form, md.winner_teamid, f.id, f.competition_id, f.roundtitle, f.matchstate, f.venue, f.venuecity, f.matchcentreurl, f.kickofftime, home_team.team_id, home_team.nickname, home_team.competition_id, away_team.team_id, away_team.nickname, away_team.competition_id
FROM match_details md
JOIN fixtures f ON md.fixture_id = f.id
JOIN teams home_team ON md.homeTeam_id = home_team.id
JOIN teams away_team ON md.awayTeam_id = away_team.id
ORDER BY f.kickOffTime
`

type ListMatchDetailsRow struct {
	MatchDetail MatchDetail
	Fixture     Fixture
	Team        Team
	Team_2      Team
}

// Retrieve all match details available in the system.
func (q *Queries) ListMatchDetails(ctx context.Context) ([]*ListMatchDetailsRow, error) {
	rows, err := q.db.Query(ctx, listMatchDetails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListMatchDetailsRow
	for rows.Next() {
		var i ListMatchDetailsRow
		if err := rows.Scan(
			&i.MatchDetail.FixtureID,
			&i.MatchDetail.HometeamID,
			&i.MatchDetail.AwayteamID,
			&i.MatchDetail.HometeamOdds,
			&i.MatchDetail.AwayteamOdds,
			&i.MatchDetail.HometeamScore,
			&i.MatchDetail.AwayteamScore,
			&i.MatchDetail.HometeamForm,
			&i.MatchDetail.AwayteamForm,
			&i.MatchDetail.WinnerTeamid,
			&i.Fixture.ID,
			&i.Fixture.CompetitionID,
			&i.Fixture.Roundtitle,
			&i.Fixture.Matchstate,
			&i.Fixture.Venue,
			&i.Fixture.Venuecity,
			&i.Fixture.Matchcentreurl,
			&i.Fixture.Kickofftime,
			&i.Team.TeamID,
			&i.Team.Nickname,
			&i.Team.CompetitionID,
			&i.Team_2.TeamID,
			&i.Team_2.Nickname,
			&i.Team_2.CompetitionID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMatchDetailsByCompetitionID = `-- name: ListMatchDetailsByCompetitionID :many
SELECT md.fixture_id, md.hometeam_id, md.awayteam_id, md.hometeam_odds, md.awayteam_odds, md.hometeam_score, md.awayteam_score, md.hometeam_form, md.awayteam_form, md.winner_teamid, f.id, f.competition_id, f.roundtitle, f.matchstate, f.venue, f.venuecity, f.matchcentreurl, f.kickofftime, home_team.team_id, home_team.nickname, home_team.competition_id, away_team.team_id, away_team.nickname, away_team.competition_id
FROM match_details md
JOIN fixtures f ON md.fixture_id = f.id
JOIN teams home_team ON md.homeTeam_id = home_team.id
JOIN teams away_team ON md.awayTeam_id = away_team.id
WHERE f.competition_id = $1
ORDER BY f.kickOffTime
`

type ListMatchDetailsByCompetitionIDRow struct {
	MatchDetail MatchDetail
	Fixture     Fixture
	Team        Team
	Team_2      Team
}

// Retrieve all match details for a specific competition ID.
// This query performs a JOIN between match_details and fixtures to get all
// match details that are part of a specific competition.
func (q *Queries) ListMatchDetailsByCompetitionID(ctx context.Context, competitionID int64) ([]*ListMatchDetailsByCompetitionIDRow, error) {
	rows, err := q.db.Query(ctx, listMatchDetailsByCompetitionID, competitionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListMatchDetailsByCompetitionIDRow
	for rows.Next() {
		var i ListMatchDetailsByCompetitionIDRow
		if err := rows.Scan(
			&i.MatchDetail.FixtureID,
			&i.MatchDetail.HometeamID,
			&i.MatchDetail.AwayteamID,
			&i.MatchDetail.HometeamOdds,
			&i.MatchDetail.AwayteamOdds,
			&i.MatchDetail.HometeamScore,
			&i.MatchDetail.AwayteamScore,
			&i.MatchDetail.HometeamForm,
			&i.MatchDetail.AwayteamForm,
			&i.MatchDetail.WinnerTeamid,
			&i.Fixture.ID,
			&i.Fixture.CompetitionID,
			&i.Fixture.Roundtitle,
			&i.Fixture.Matchstate,
			&i.Fixture.Venue,
			&i.Fixture.Venuecity,
			&i.Fixture.Matchcentreurl,
			&i.Fixture.Kickofftime,
			&i.Team.TeamID,
			&i.Team.Nickname,
			&i.Team.CompetitionID,
			&i.Team_2.TeamID,
			&i.Team_2.Nickname,
			&i.Team_2.CompetitionID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMatchDetail = `-- name: UpdateMatchDetail :one
UPDATE match_details 
SET 
    homeTeam_odds = COALESCE($2, homeTeam_odds), 
    awayTeam_odds = COALESCE($3, awayTeam_odds), 
    homeTeam_score = COALESCE($4, homeTeam_score), 
    awayTeam_score = COALESCE($5, awayTeam_score), 
    winner_teamId = COALESCE($6, winner_teamId)
WHERE fixture_id = $1
RETURNING fixture_id, hometeam_id, awayteam_id, hometeam_odds, awayteam_odds, hometeam_score, awayteam_score, hometeam_form, awayteam_form, winner_teamid
`

type UpdateMatchDetailParams struct {
	FixtureID     int64
	HomeTeamOdds  *float64
	AwayTeamOdds  *float64
	HomeTeamScore *int32
	AwayTeamScore *int32
	WinnerTeamId  *int64
}

// Conditionally update match detail fields based on provided arguments.
// Only updates fields where the argument is not NULL.
func (q *Queries) UpdateMatchDetail(ctx context.Context, arg UpdateMatchDetailParams) (*MatchDetail, error) {
	row := q.db.QueryRow(ctx, updateMatchDetail,
		arg.FixtureID,
		arg.HomeTeamOdds,
		arg.AwayTeamOdds,
		arg.HomeTeamScore,
		arg.AwayTeamScore,
		arg.WinnerTeamId,
	)
	var i MatchDetail
	err := row.Scan(
		&i.FixtureID,
		&i.HometeamID,
		&i.AwayteamID,
		&i.HometeamOdds,
		&i.AwayteamOdds,
		&i.HometeamScore,
		&i.AwayteamScore,
		&i.HometeamForm,
		&i.AwayteamForm,
		&i.WinnerTeamid,
	)
	return &i, err
}
